<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>CraftBlocks by @sgidon: 8th Wall Web: A-FRAME</title>
  <style type="text/css">
    body {
      user-select:none;
      -webkit-user-select:none;
      -moz-user-select:none;
      -khtml-user-select:none;
      -webkit-user-drag:none;
      -khtml-user-drag:none;
    }
    
    select {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
    }
    
    select#menuSelector {
      position:absolute;
      width:80px;
      height:40px;
      top:10px;
      left:5px;
      z-index:100;
    }
    
    select#blockSelector {
      position:absolute;
      width:130px;
      height:40px;
      bottom:20px;
      left: 5px;
      z-index:100;
      background-size:contain;
      background-repeat:no-repeat;
      text-indent: 45px;
    }
  
    #recenter {
      position:absolute;
      width:80px;
      height:40px;
      right:5px;
      top:10px;
      z-index:100;
    }
  
    #colorPicker {
      position:absolute;
      width:130px;
      height:40px;
      right:5px;
      bottom:20px;
      z-index:100;
    }
  
    select#colorSelector {
      position:absolute;
      width:130px;
      height:40px;
      right:5px;
      bottom:20px;
      z-index:100;
    }

    #shotButton {
      position:absolute;
      width:80px;
      height:80px;
      bottom:20px;
      left: 0;
      right: 0;
      z-index:200;
      margin: auto;
      visibility: hidden;
    }
    
    div#debugConsole {
      position:absolute;
      width:75%;
      height:75%;
      top:5px;
      right:5px;
      z-index:200;
      opacity:0.8;
      background-color:gray;
      color:white;
      visibility:hidden;
      overflow:auto;
    }
    
    video#imgPicker {
      position:absolute;
      width:90%;
      height:90%;
      top:5%;
      left:5%;
      z-index:100;
      visibility:hidden;
    }
    
    div#markerPos {
      position:absolute;
      width: 40%;
      height: 30px;
      top: 15px;
      left: 30%;
      z-index:100;
      visibility:visible;
      opacity:0.8;
      background-color: white;
      text-align:center;
      vertical-align: middle;
    }
    
    div#markerPos p {
      position: relative;
      -webkit-transform: translateY(-50%);
      -ms-transform: translateY(-50%);
      transform: translateY(-50%);
    }
  
  </style>

  <script src="https://cdn.8thwall.com/web/aframe/8frame-0.8.2.min.js"></script>
<!-- local dev only
  <script src="./js/8frame-v0.8.2.min.js"></script>
-->
  <!-- 8thWall Web - Replace the app key here with your own app key -->
  <script src="https://apps.8thwall.com/xrweb" appKey="lqeTy4aV0Q8nXZPoc8zqAkNJYV3yal45uAmGIn3gP3SRzDnms5u2zGz5DnMcAn6JVqeDf1"></script>
  <!-- GLTF/GLB Export -->
  <script src="./js/aframe-gltf-exporter-component.js"></script>
  <script src="./js/jszip.min.js"></script>
  <!-- user script -->
  <script src="./js/script.js"></script>

  <script>
    //Global
    const _COLOR_BLOCK_IMG="colorSelector.png"
    const _WATER_IMG="water.png";
    const _QRCODE_IMG="qrcode.png";
    
    // 画面の状態
    const _MODE_CRAFT=0;
    const _MODE_SHOT=1;
    const _MODE_CREATE=2;
    
    var _f_shotMode = false;
    
    // 各部品はGLOBALに持つようにしてみた
    var menuSelector;
    var buttonRecenter;
    var blockSelector;
    var colorSelector;
    var colorPicker;
    var shotButton;
    var imgPicker;
    var markerPos;
    var scene;
    var cvs;
    var ctx;
    var imgLink = document.createElement("a");

    // Component
    AFRAME.registerComponent('collider-check', {
      dependencies: ['raycaster'],
    
      init: function () {

        var el = this.el;
        var data = this.data;

        const scene = this.el.sceneEl
        const clickTime = 300; // msec
        const intervalTime = 100; // msec
        
        var blockList = document.createElement("a-entity");
        blockList.id = "blockList";
        scene.appendChild(blockList);
        
        colorPicker = document.querySelector("#colorPicker");
        blockSelector = document.querySelector("#blockSelector");
        buttonRecenter = document.querySelector("#recenter");

        markerPos = document.querySelector("#markerPos");
        data.info = document.createElement("p");
        data.info.id = "info";
        markerPos.appendChild(data.info);
        
        buttonRecenter.addEventListener('click', () => {
          scene.emit('recenter', {});
        })
        
        scene.addEventListener('touchstart', () => {
          if (_f_shotMode) {
            changeMode(_MODE_CRAFT);
            return true;
          }
          
          data.touchStartTime = new Date();
        })
        
        scene.addEventListener('touchend', () => {
          if ((new Date() - data.touchStartTime) < clickTime && data.pos) {
            let box = document.createElement("a-box");
            box.className = "block";
            if (blockSelector.value == _COLOR_BLOCK_IMG) {
              box.setAttribute("color", colorPicker.value);
              box.setAttribute("material","shader","standard");
            } else {
              box.setAttribute("material","shader","standard");
              box.setAttribute("material","src",'#' + blockSelector.value);
              if (blockSelector.value == _WATER_IMG) {
                box.setAttribute("opacity", 0.9);
              }
            }
            box.setAttribute("position", data.pos);
            box.setAttribute("scale", "1.01 1.01 1.01");

            blockList.appendChild(box);
          }
          data.touchStartTime = '';
          data.flgRmBox = false;
          
        })
        
        scene.addEventListener('deleteAll',() => {
          console.log("emit: deleteAll");
          blockList.parentNode.removeChild(blockList);
          blockList = document.createElement("a-entity");
          blockList.id = "blockList";
          scene.appendChild(blockList);
        })
        
        scene.addEventListener('save',() => {
          console.log("emit: save");
          try {
            let data = {};
            data["datetime"] = new Date();
            data["title"] = "";
            data["comment"] = "";
            data["list"] = [];
            let list = document.getElementsByClassName("block");
            
            // とりあえず動いた。暫定的な書き方。
            for (var i = 0; i < list.length; i++) {
              let block = [];
              const attr = ["class","color","material.shader","material.src","opacity","position","scale"];
              block.push({class: (list[i].getAttribute("class") ? list[i].getAttribute("class") : "")});
              block.push({color: (list[i].getAttribute("color") ? list[i].getAttribute("color") : "")});
              block.push({materialShader: (list[i].getAttribute("material").shader ? list[i].getAttribute("material").shader : "")});
              block.push({materialSrc: (list[i].getAttribute("material").src.id ? list[i].getAttribute("material").src.id : "")});
              console.log(list[i].getAttribute("material").src);
              console.log(list[i].getAttribute("material").src.id);
              block.push({opacity: (list[i].getAttribute("opacity") ? list[i].getAttribute("opacity") : "")});
              block.push({position: (list[i].getAttribute("position") ? list[i].getAttribute("position") : "")});
              block.push({scale: (list[i].getAttribute("scale") ? list[i].getAttribute("scale") : "")});
              data["list"].push(block);
            }
            localStorage.setItem("save1",JSON.stringify(data));
          } catch(e) {
            // 本来呼び出し元で実行すべきだろうが、知識不足でこちらで呼ぶ。
            alert("セーブに失敗しました。もう一度実行してください。");
          }
          // 本来呼び出し元で実行すべきだろうが、知識不足でこちらで呼ぶ。
          alert("セーブしました。");
        })

        scene.addEventListener('load',() => {
          console.log("emit: load");
          scene.emit("deleteAll");
          
          try {
            let data = JSON.parse(localStorage.getItem("save1"));
            let list = data["list"];
            
            // とりあえず動いた、暫定的な書き方。
            // javascriptの配列<->JSONのやり方の理解が追いついてない。
            // しかしなんてアホな書き方なんだ・・・
            for (let i = 0; i < list.length; i++) {
              let box = document.createElement("a-box");
              box.className = list[i][0].clsss;
              if (list[i][1].color != "") {
                box.setAttribute("color", list[i][1].color);
                box.setAttribute("material","shader",list[i][2].materialShader);
              } else {
                box.setAttribute("material","shader",list[i][2].materialShader);
                box.setAttribute("material","src","#"+list[i][3].materialSrc);
                box.setAttribute("opacity", list[i][4].opacity);
              }
              box.setAttribute("position", list[i][5].position);
              box.setAttribute("scale", list[i][6].scale);
  
              blockList.appendChild(box);
            }
          } catch(e) {
            // 本来呼び出し元で実行すべきだろうが、知識不足でこちらで呼ぶ。
            alert("ロードに失敗しました。もう一度実行してください。");
          }
          // 本来呼び出し元で実行すべきだろうが、知識不足でこちらで呼ぶ。
          alert("ロードしました。");
        })

        scene.addEventListener('exportGltf',() => {
          console.log("emit: exportGltf");
          let options = {
            trs: false,
            onlyVisible: true,
            truncateDrawRange: true,
            binary: false,
            forceIndices: false,
            forcePowerOfTwoTextures: false
          };
          scene.systems['gltf-exporter'].export(blockList, options);
        })

        scene.addEventListener('exportGlb',() => {
          console.log("emit: exportGlb");
          let options = {
            trs: false,
            onlyVisible: true,
            truncateDrawRange: true,
            binary: true,
            forceIndices: false,
            forcePowerOfTwoTextures: false
          };
          scene.systems['gltf-exporter'].export(blockList, options);
        })

        data.target = document.querySelector("#target");
        data.marker = document.querySelector("#marker");
        data.offsetY = data.marker.getAttribute("scale").y/2;
        
        // main loop
        setInterval(function() {
          el.components.raycaster.refreshObjects();
          let intersection = getNearestIntersection(el.components.raycaster.intersections);
          if (intersection) {
            if (_f_shotMode == 0) {
              if (intersection.object.el.getAttribute("material").src.id == _QRCODE_IMG) {
                data.marker.setAttribute("visible", false);
                data.target.setAttribute("visible", false);
              } else {
                data.marker.setAttribute("visible", true);
                data.target.setAttribute("visible", true);
              }
            }
            if (data.touchStartTime) {
              if (!data.flgRmBox && (new Date() - data.touchStartTime) > clickTime) {
                if (intersection.object.el.className == 'block') {
                  intersection.object.el.parentNode.removeChild(intersection.object.el);
                }
                data.flgRmBox = true;
              }
            } else {
              let pos = intersection.point;
              pos.x = Math.round(pos.x);
              pos.y = Math.round(pos.y - data.offsetY <= 0 ? 0 : pos.y - data.offsetY ) + data.offsetY;
              pos.z = Math.round(pos.z);
              data.marker.setAttribute("position", pos);
              data.pos = pos;
            }
            if (data.pos) {
              data.info.innerHTML = "X:"+ data.pos.x+" Y:" +(data.pos.y - data.offsetY)+" Z:"+data.pos.z;
            } else {
              data.info.innerHTML = "";
            }
          } else {
            data.pos = "";
            data.marker.setAttribute("visible", false);
            data.info.innerHTML = "";
          }
        }, intervalTime)

        // get target intersection
        function getNearestIntersection(intersections) {
          for (var i = 0, l = intersections.length; i < l; i++) {
              // ignore cursor itself to avoid flicker && ignore "ignore-ray" class
              if (data.target === intersections[i].object.el || intersections[i].object.el.classList.contains("ignore-ray")) { continue; }
              return intersections[i];
          }
          return null;
        }
        
      }
    });

    // 画面制御処理
    window.onload = function() {
      console.log("onload finish");
      cvs = document.getElementsByTagName("canvas")[0];
      ctx = cvs.getContext("2d");

      menuSelector = document.querySelector("#menuSelector");
      blockSelector = document.querySelector("#blockSelector");
      colorSelector = document.querySelector("#colorSelector");
      colorPicker = document.querySelector("#colorPicker");
      shotButton = document.querySelector("#shotButton");
      imgPicker = document.querySelector("#imgPicker");
      buttonRecenter = document.querySelector("#recenter");
      markerPos = document.querySelector("#markerPos");

      scene = document.querySelector("a-scene");

      // Query String
      var queryString = getQueryString();

      // Debug Console
      if (queryString && queryString["debug"] == "true") {
        let debugConsole = document.querySelector("#debugConsole");
        debugConsole.style.visibility = "visible";
        console.log = function(log) {
          debugConsole.innerHTML += log + "<br>";
        }
      }

      // menu selectorの動作
      menuSelector.onchange = function(e) {
        console.log(this.value);
        if (this.value == "menu") {
          return true;
        } else if (this.value == "new") {
          var result = confirm("すべてのブロックを削除しますか？");
          if (result) {
            scene.emit('deleteAll');
          }
          this.value="menu";
          return true;
        } else if (this.value == "recenter") {
          scene.emit('recenter', {});
          this.value="menu";
          return true;
        // } else if (this.value == "createBlock") {
        //   // オリジナルブロック作成用VIDEO設定
        //   getVideoStream(imgPicker);
        //   changeMode(_MODE_CREATE);
        //   this.value="menu";
        //   return true;
        } else if (this.value == "save") {
          var result = confirm("セーブします。");
          if (result) {
            scene.emit('save');
          }
          this.value="menu";
          return true;
        } else if (this.value == "load") {
          var result = confirm("ロードします。今のブロックは削除されます。");
          if (result) {
            scene.emit('load');
          }
          this.value="menu";
          return true;
        } else if (this.value == "shot") {
          this.value="menu";
          changeMode(_MODE_SHOT);
          return true;
        } else if (this.value == "gltf") {
          this.value="menu";
          scene.emit('exportGltf', {});
          return true;
        } else if (this.value == "glb") {
          this.value="menu";
          scene.emit('exportGlb', {});
          return true;
        }
        this.value="menu";
      }

      // block selectorの見栄え
      blockSelector.onchange = function(e) {
        this.style.backgroundImage="url(./images/" + this.value + ")";
      }
      
      // iOS用：Safariの場合はColorPickerではなくColorSelectorを表示する。
      if (getUserAgent() == "safari") {
        console.log("safari");
        colorPicker.style.display = "none";
        
        colorSelector.onchange = function(e) {
          this.style.background=this.value;
          this.style.color=this.value;
          colorPicker.value=this.value;

          // 色変更時は自動的にblockSelectorを色ブロックに変更する。
          blockSelector.value = _COLOR_BLOCK_IMG;
          blockSelector.style.backgroundImage="url(./images/" + _COLOR_BLOCK_IMG + ")";
        }
      } else {
        console.log("not safari");
        colorSelector.style.display = "none";
        
        colorPicker.onchange = function(e) {
          // 色変更時は自動的にblockSelectorを色ブロックに変更する。
          blockSelector.value = _COLOR_BLOCK_IMG;
          blockSelector.style.backgroundImage="url(./images/" + _COLOR_BLOCK_IMG + ")";
        }
      }
      
      // 撮影ボタンクリック動作
      shotButton.onclick = function(e) {
        // not work well...
        console.log("onClick shot");
        getScreenShot();
        changeMode(_MODE_CRAFT);
      }

    }
    
    function getScreenShot() {
      let filename = "craftblocks"+ getFormatDateTime()+".png";

      let screenshot = document.querySelector("a-scene").components.screenshot
      screenshot.resize(window.width, window.height);
      let base64 = screenshot.getCanvas("perspective").toDataURL();
      let blob = base64toBlob(base64);
      if (window.navigator.msSaveBlob) {
        window.navigator.msSaveBlob(blob, filename);
      } else {
        imgLink.href = window.URL.createObjectURL(blob);
        imgLink.download = filename;
        imgLink.click();
      }
    }
    
    function changeMode(modeNum) {
      // mode change
      _f_shotMode = modeNum == _MODE_CRAFT? 0 : 1;
      let statusOfShotElement = _f_shotMode ? "visible" : "hidden";
      let statusOfCraftElement = _f_shotMode ? "hidden" : "visible";
      let statusOfCreateElement = modeNum == _MODE_CREATE ? "visible" : "hidden";
      
      // shot mode element
      
      // craft mode element
      menuSelector.style.visibility = statusOfCraftElement;
      blockSelector.style.visibility = statusOfCraftElement;
      if (getUserAgent() == "safari") {
        colorSelector.style.visibility = statusOfCraftElement;
      } else {
        colorPicker.style.visibility = statusOfCraftElement;
      }
      buttonRecenter.style.visibility = statusOfCraftElement;
      markerPos.style.visibility = statusOfCraftElement;

      // block create mode element
      shotButton.style.visibility = statusOfCreateElement;
      imgPicker.style.visibility = statusOfCreateElement;

      // scene entity
      document.querySelector("#target").setAttribute("visible", !_f_shotMode);
      document.querySelector("#marker").setAttribute("visible", !_f_shotMode);
      document.querySelector("#floor").setAttribute("visible", !_f_shotMode);
      
      // screen controll
      if (_f_shotMode) {
        enterFullscreen();
      } else {
        exitFullscreen();
      }

    }
    
  </script>

</head>
<body>
  <a-scene xrweb>
    <a-assets>
      <img id="water.png" src="./images/water.png">
      <img id="grass.png" src="./images/grass.png">
      <img id="leaves.png" src="./images/leaves.png">
      <img id="qrcode.png" src="./images/qrcode.png">
      <img id="sand.png" src="./images/sand.png">
      <img id="stone2.png" src="./images/stone2.png">
      <img id="stone3.png" src="./images/stone3.png">
      <img id="stone.png" src="./images/stone.png">
      <img id="tatami2.png" src="./images/tatami2.png">
      <img id="tatami.png" src="./images/tatami.png">
      <img id="wood-panel.png" src="./images/wood-panel.png">
      <img id="wood-log.png" src="./images/wood-log.png">
    </a-assets>

    <a-camera position="0 20 20">
      <a-cursor id="target" raycaster="objects: .collidable, .block, .floor" collider-check></a-cursor>
    </a-camera>

    <a-plane id="floor" class="floor" rotation="-90 0.01 0" width=25 height=25 opacity=0.5></a-plane>
    <a-box id="marker" class="non-collidable" color="white" position="0 999 0" wireframe="true" opacity="0.5"></a-box>
        
  </a-scene>
  
  <!-- メニュー -->
  <select id="menuSelector" name="menuselector" style="background-color:white;">
    <option value="menu" selected>メニュー</option>
    <option value="new">　ブロック全削除</option>
<!--
    <option value="createBlock">ブロック作成</option>
-->
    <option value="save">　セーブ</option>
    <option value="load">　ロード</option>
    <option value="shot">　スクショモード</option>
    <option value="gltf">　glTF 出力</option>
    <option value="glb">　GLB 出力</option>
  </select>

  <!-- ブロックの選択ダイアログ -->
  <select id="blockSelector" name="blockselector" style="background-color:white; background-image:url(./images/colorSelector.png);">
    <option value="water.png">水</option>
    <option value="sand.png">砂</option>
    <option value="wood-panel.png">木板</option>
    <option value="tatami.png">畳</option>
    <option value="stone.png">砂利</option>
    <option value="stone2.png">石垣</option>
    <option value="stone3.png">石畳</option>
    <option value="grass.png">草</option>
    <option value="wood-log.png">木</option>
    <option value="leaves.png">葉っぱ</option>
    <option value="colorSelector.png" selected>色付き</option>
    <option value="qrcode.png">QRcode</option>
  </select>
  
  <input type="button" id="recenter" value="ここに移動">
  
  <!-- カラーブロックの色選択ダイアログ。iOS用とそれ以外用がある -->
  <input type="color" id="colorPicker" value="#0000FF">
  <select id="colorSelector" name="colorselector" style="background:#0000FF; color:#0000FF">
    <option value="#0000FF" style="background:#0000FF; color:#0000FF" selected>ブルー</option>
    <option value="#FFFFFF" style="background:#FFFFFF; color:#FFFFFF">ホワイト</option>
    <option value="#FFC0CB" style="background:#FFC0CB; color:#FFC0CB">ピンク</option>
    <option value="#EE82EE" style="background:#EE82EE; color:#EE82EE">バイオレット</option>
    <option value="#FFFF00" style="background:#FFFF00; color:#FFFF00">イエロー</option>
    <option value="#FFA500" style="background:#FFA500; color:#FFA500">オレンジ</option>
    <option value="#808080" style="background:#808080; color:#808080">グレー</option>
    <option value="#A52A2A" style="background:#A52A2A; color:#A52A2A">ブラウン</option>
    <option value="#008000" style="background:#008000; color:#008000">グリーン</option>
    <option value="#FF0000" style="background:#FF0000; color:#FF0000">レッド</option>
    <option value="#00FF00" style="background:#00FF00; color:#00FF00">ライム</option>
    <option value="#000000" style="background:#000000; color:#000000">ブラック</option>
  </select>
    
  <!-- 写真撮影用ボタン -->
  <img src="./images/button_shot.png" id="shotButton">

  <!-- オリジナルブロック撮影用VIDEO -->
  <video id="imgPicker"></video>

  <!-- マーカー位置表示 -->
  <div id="markerPos"></div>

  <!-- debug console -->
  <div id="debugConsole"></div>

</body>
</html>
